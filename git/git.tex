\documentclass[UTF8]{ctexart}
\usepackage{fontspec}
\defaultfontfeatures{Mapping=tex-text}
\usepackage{xunicode}
\usepackage{xltxtra}
%\setmainfont{???}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}
\author{高睿昊}
\title{\zihao{0}\heiti Git学习笔记}
\newenvironment{myquote}
  {\begin{quote}\kaishu\zihao{-5}}
  {\end{quote}}
  
  
  \usepackage{listings}
  \lstset{
frame=tbrl,
showstringspaces=false,
flexiblecolumns}





\begin{document}
\maketitle
{\center 教程蓝本：《廖雪峰的git教程》

网址：http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000}
\section{安装git}
一提到git，大佬们常说：
\begin{myquote}
\kaishu “Git是目前世界上最先进的分布式版本控制系统”
\end{myquote}
所以我们必须理解Git实际上是一个软件，同样需要安装。

在Ubuntu上安装Git的命令：\lstinline!$sudo apt-get install git! 。（Windows和Mac上面的安装很简单，问度娘就好了）
安装完成以后还需要配置账户信息
\begin{lstlisting}[language=bash]
$ git config --global user.name "YourName"
$ git config --global user.email "email@example.com"
\end{lstlisting}

\section{创建版本库}
在需要Git管理的目录下执行命令：
\begin{lstlisting}[language=bash]
$ git init
\end{lstlisting}
对于需要Git管理的目录需要使用add命令进行处理
\begin{lstlisting}[language=bash]
$ git add 文件名或者目录名
\end{lstlisting}
最后使用commit命令即可提交到版本库
\begin{lstlisting}[language=bash]
$ git commit -m “用于识别的附加在提交后面的消息”
\end{lstlisting}

\section{Git时光机}
\textbf{git status}命令可以让我们时刻掌握仓库当前的状态，上面的命令告诉我们，readme.txt被修改过了，但还没有准备提交的修改。

\textbf{git diff}顾名思义就是查看difference，显示的格式正是Unix通用的diff格式，可以从上面的命令输出看到，我们在第一行添加了一个“distributed”单词。

当我们对文件修改后再提交时，也要经过添加新的文件的add和commit命令。

\subsection{版本回退}
在Git中，可以用git log命令查看提交的版本信息，例如在编写个笔记过程中使用的log是这样的：
\begin{lstlisting}
commit a0a5fe4e08f77bc5bf609b27575206cb7cb1ccb2
Author: Acinonyx Tungsten <gaoruihao@outlook.com>
Date:   Thu Feb 9 19:54:30 2017 +0800

    1

commit 047711edf118019cd76d9628d3d61b6022f6b008
Author: Acinonyx Tungsten <gaoruihao@outlook.com>
Date:   Thu Feb 9 08:39:34 2017 +0800

    add a line

commit 41320d5047bf318ab067352bfaa5ce658646d188
Author: Acinonyx Tungsten <gaoruihao@outlook.com>
Date:   Thu Feb 9 08:33:59 2017 +0800

    first time
\end{lstlisting}

这样看起来比较烦的话可以用\verb！ $ git log --pretty=oneline！，得到的结果是这样的：
\begin{lstlisting}
wolf-tungsten@wolftungsten-ThinkPad-T460p:~/NotePapers$ git log --pretty=oneline
a0a5fe4e08f77bc5bf609b27575206cb7cb1ccb2 1
047711edf118019cd76d9628d3d61b6022f6b008 add a line
41320d5047bf318ab067352bfaa5ce658646d188 first time
\end{lstlisting}

前面一串串的数字就是十六进制表示的版本号了（官方名称是commit id）。当我们想回退到上一个版本的时候，就可以用命令\verb!$ git reset --hard HEAD^!。其中HEAD代表当前版本，\^就代表上一个版本——以此类推\verb!$ git reset --hard HEAD^^!自然就是回退到两个版本啦。

现在我们相当于从21世纪回到了19世纪，那我们要如何再从19实际回到21世纪呢？这时候刚才看起来烦人的commit id就有大用了。首先我们使用\verb!$ git reflog !命令来查看各个提交版本的commit id：
\begin{lstlisting}[language=bash]
wolf-tungsten@wolftungsten-ThinkPad-T460p:~/NotePapers$ git reflog
a0a5fe4 HEAD@{0}: commit: 1
047711e HEAD@{1}: commit: add a line
41320d5 HEAD@{2}: commit (initial): first time
\end{lstlisting}
然后\verb!$ git reset --hard 047711e!，就会回到这个版本。这样的话，时光机就可以任意穿梭了。

\subsection{撤销修改}
首先我们必须了解git的\textbf{工作区}和\textbf{暂存区}：我们实际操作的文件处于工作区，add命令的执行就是将工作区的内容添加到了暂存区，commit命令将暂存区的内容正式提交至版本仓库。

git的存在相当于给文件修改添加了撤销功能，\verb!$ git checkout -- 文件名或者目录名 ! 可以让文件恢复到最近一次commit或者add的状态。
如果改动已经提交到了暂存区，就要使用\verb!$ git reset HEAD 文件名或者目录名! 把文件撤回到工作区进一步修改之后再进行add和commit的操作。

\begin{list}{场景}{\textbf{撤销更改的几种情况}}
\item[场景1]当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。
\item[场景2]当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作。
\item[场景3]已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。
\end{list}

\subsection{删除文件}
删除文件是一种常见操作。简单的来说我们可以直接在工作区删除一个文件，然后作为一个新版本提交到版本库，这样我们可以随时利用前面的版本回退，或者撤销更改的方法去“一键还原”。

或者，我们可以采用\verb! $ git rm 文件或者目录 !命令直接从工作区、版本库删除这个文件。

如果发现删错了，那么还可以用\verb!$ git checkout --文件或目录 !将其恢复为版本库中最新的版本。

\section{分支管理}
\subsection{创建与合并分支}
这里以创建dev分支并合并到master分支并最后将其删除为例进行讲解：
\begin{itemize}
\zihao{5}
\item 创建dev分支并切换到dev分支：\verb!$ git checkout -b dev!。checkout命令加上-b参数表示创建和切换。现在可以随心所欲的对dev分支进行修改，而不影响master分支的情况。
\item 通过\verb!$ git branch!命令可以查看现有的分支。
\item 知道了有哪些分支以后就可以再次使用\verb!$ git checkout 分支名!来切换到需要的分支。
\item 合并分支\footnote{需要注意一般情况下是把超前的分支（本例中的dev分支）合并到滞后的分支上（本例中的master分支）。} 首先我们切换到master分支\verb!$ git checkout master!，然后使用\verb!$ git merge dev!命令最终把dev合并到当前分支上。
\item 合并完成后就可以把dev分支删除\verb!$ git branch -d dev!。
\end{itemize}
由于创建dev分支后，没有再对master分支进行修改，所以合并分支的时候git自动为我们使用了“fast-forward”。后面会说明不能Fast-forward的情况以及解决办法。

\subsection{冲突的产生与解决}
在上一节中，创建了dev分支，之后所有的更改都是在dev分支上进行的。下面就要来处理：“创建dev分支后，又对master分支修改”的情况。如果直接进行合并，就会产生冲突。
\begin{lstlisting}
wolf-tungsten@wolftungsten-ThinkPad-T460p:~/test$ git merge dev
自动合并 test
冲突（内容）：合并冲突于 test
\end{lstlisting}
这时就要使用\verb!$ git status!命令来查看究竟是哪个文件出了问题

\begin{lstlisting}
wolf-tungsten@wolftungsten-ThinkPad-T460p:~/test$ git status
位于分支 master
您有尚未合并的路径。
  （解决冲突并运行 "git commit"）

未合并的路径：
  （使用 "git add <文件>..." 标记解决方案）

	双方修改：   test

修改尚未加入提交（使用 "git add" 和/或 "git commit -a"）
\end{lstlisting}
打开冲突的test文件你会发现它变成了这样：
\begin{lstlisting}[language=bash]
first
<<<<<<< HEAD
add on master
=======
add in dev
>>>>>>> dev
\end{lstlisting}
这其中用\verb!<<<<<<<\=======\>>>>>>>!标记出来的就是冲突的地方，按照需求修改再保存就可以正确合并了。

再次提交后，用带参数的git log可以查看合并的情况：
\begin{lstlisting}[language=bash]
wolf-tungsten@wolftungsten-ThinkPad-T460p:~/test$ git log --graph --pretty=oneline 
--abbrev-commit
*   0ee2246 2on master
|\  
| * 0cb0c0b 2 on dev
* | 99d0183 commit on master
|/  
* c59e421 1
\end{lstlisting}
\subsection{禁用Fast Forward}
合并的时候如果可以使用fastforward固然很爽，但是带来的代价是，一旦我们删除分支，那么分支记录就完全丢失了。这里可以在合并的时候加入\verb！--no-ff！参数来禁用fastforward。

完整的命令：\verb!git merge --no-ff -m "merge with no-ff" dev!。因为合并后会产生一个新的提交，所以还是需要-m补充提交的信息。实际开发过程应该尊崇如下的管理规则：
\begin{myquote}
在实际开发中，我们应该按照几个基本原则进行分支管理：
\begin{enumerate}
\item master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；
\item 干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；
\item 每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了
\end{enumerate}
\end{myquote}



\end{document}